[TOC]

# Introduction

The goal of EspR4FastData is to provide a Complex Event Processor (CEP) at the gateway level with a NGSI 9/10 interface for the Fiware Data Handling GE.

EspR4FastData allows to locally process basic events (from data provided by sensors) and generate high-level aggregated events.
All input and output of events is done though HTTP requests conforming to the NGSI information model.

# Glossary

##Fiware terms

- Gateway / edge:  intermediary NGSI component, optional executing EspR4FastData (typically a RaspberryPi deployed near the sensors).
- Sensors : NGSI capable devices that can transmit some data as Context Entities to other NGSI enabled components.

## NGSI terms

These terms are here described using more common software engineering terms.

- Context Information model : the global name of the NGSI data model
- Context Providers / Context Producers : source of Context Elements updates
- Context Managers / Broker : service that can host / forward Context Entities
- Context Entity / Element : a class (e.g. a person, place, event, thing) defining a group of attributes
- Context Attributes : attributes associated to a Context Entity
- Metadata : some metadata associated to each attributes of a Context Element
- Entity Id: the unique id of a Context Entity
- Entity Type : the type of a Context Entity


## CEP terms

These terms are described using the NGSI terminology.

- Event : an update to the state of Context Entity
- Event type : the set of attributes an event can update.
- Stream : a flow of events of the same type.
- Incoming events : a stream generated by Context Providers and that are addressed to the CEP engine (seen as a Context Manager)
- Outgoing events : a stream generated by the CEP engine (seen as a Context Producer) in result of applying statements to incoming events and sent to a Context Broker.
- Statements : a set of rules that are applied by the CEP engine to incoming events and that generates outgoing events.

# Mapping Context Entities to Events

The CEP engine works by processing incoming events and generating outgoing events. These concepts can be mapped quite easily to updates of Context Entities in the NGSI data model.

When the CEP engine is addressed an update to a Context Entity using the NGSI 10 /updateContext request, it will fire the corresponding events and process the related EPL statements. If one or more outgoing events are fired by the CEP engine, the corresponding /updateContext requests will be called to notify Context Brokers of the updates to the mapped Context Entities.

## Restrictions

The Esper CEP engine imposes several restrictions to the Context Entities.

### Type is mandatory

All events must have a given type (an Event type) that define a strict set of typed attributes. Event types must be declared before any event can be processed by the CEP engine.
Based on this strong requirement, the EspR4FastData implementation **requires** the updates made by the Context Providers to provide a mandatory `type` field for all Context Entities.
Updates to Context Elements missing this type information will be discarded.

### Id is a reserved attribute key

Another consequence is that the `id` field is handled by CEP engine as just another attribute of the event. Therefore no Context Attribute is allowed to be named `id`.

### Simple attribute types

The current version of the CEP engine only handle simple attribute types (like string, int, float, ...) and cannot execute statements for complex types like objects or arrays because of the stronly typed nature of the CEP engine.

Note: A later version will support complex values by flattening values using [JSON path](http://goessner.net/articles/JsonPath/) expressions.

## A more visual mapping

It is possible to visualize a stream of events as a SQL database table.
For each type, we define a table with columns for the `id` and each attribute. Each event is represented by a single row.

For example, the following Context Entities :
```
  {
    "id": "SENSOR1",
    "type":"RoomSensors",
    "attr": [
      { "name": "T°", "type": "float", "value": "21" },
      { "name": "Pressure", "type": "integer", "value": "560" }
    ]
  },
  {
    "id": "SENSOR2",
    "type":"RoomSensors",
    "attr": [
      { "name": "T°", "type": "float", "value": "30" },
      { "name": "Pressure", "type": "integer", "value": "1342" }
    ]
  }
```
can be seen as this table (or event stream) named "RoomSensors":
<table>
<tr><th>ID</th><th>T°</th><th>Pressure</th></tr>
<tr><td>SENSOR1</td><td>21</td><td>560</td></tr>
<tr><td>SENSOR2</td><td>30</td><td>1342</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
</table>

# API Overview

EspR4FastData has two different APIs:
- the admin REST endpoint provides access to the current configuration and means to update it.
- the NGSI endpoints provides the means for communication with other NGSI components (Context Providers and Context Brokers).

## Setup endpoint

The setup endpoint defines a single REST endpoint where the whole EspR4FastData configuration is available. The endpoint path is '/v1/admin/config'.
The endpoint accepts GET (to return the actual JSON configuration) or POST (to apply a new JSON configuration). The endpoint will return 200 Ok on success, or 400 Bad Request if the new configuration cannot be applied.

## NGSI endpoints

Currently, EspR4FastData only supports a small subset of NGSI standard operations.

EspR4FastData can work in two different (non exclusive) configurations :
- as a broker, by receiving directly updates though the `v1/updateContext` operation.
- as a subscriber by receiving `v1/notifyContext` after it registered to a context broker using `v1/subscribeContext`.

EspR4FastData will then publish updates to Context Entities (on outgoing events) using the `v1/updateContext` to a broker.

# Configuration

The configuration received by EspR4FastData is persistently on each gateway. It is only saved once it was successfully accepted by the CEP engine. The configuration is simple JSON object containing the complete description of the behavior of the CEP engine (a set of EPL statements) and the mapping between the NGSI Context Entities and CEP Events.

This is the current format is :

```json
{
  "in": [
    {
      "id": "S.*",
      "type": "TempSensor",
      "isPattern": true,
      "attributes": [
        {
          "name": "temp",
          "type": "float"
        }
      ],
      "providers": [
        "http://localhost:1902/ngsi10"
      ]
    }
  ],
  "out": [
    {
      "id": "OUT1",
      "isPattern": false,
      "type": "TempSensorAvg",
      "attributes": [
        {
          "name": "avgTemp",
          "type": "float"
        }
      ],
      "brokers": [
        {
          "url": "http://102.232.332:1903/v1",
          "serviceName": "my",
          "servicePath": "/test/path",
          "register": false
        }
      ]
    }
  ],
  "statements": [
    "INSERT INTO 'TempSensorAvg' SELECT 'OUT1' as id,
            avg(TempSensor.temp) as avgTemp
     FROM TempSensor.win:time(86400)
     WHERE TempSensor.id = 'S1' "
  ]
}
```
### Incomming events

The "in" array defines the list of incoming events (NGSI Context Entities) the CEP expects as input from Context Providers.

There is two ways Context Providers can notify the CEP:

 - The simplest way is for the Context Provider is to send /updateContext requests to the CEP. This does not require the Context Providers to be listed in the "providers" field.
```sequence
participant IoT Agent as C
participant EspR4FastData as B

C->B: update(S1.temp, 27)
C->B: update(S1.temp, 25)
```
 - The second way (from Proposition 3) is to make the CEP subscribe to the Context Provider. For each Context Provider defined in the "providers" field of an event, the CEP will send initialy a /subscribeContext, and will expect in return the Context Provider to notify it with /notifyContext requests.

```sequence
participant Context Provider as C
participant EspR4FastData as B
B->C: subscribe(S1.temp)
C->B: notify(S1.temp, 27)
C->B: notify(S1.temp, 25)
```

### Outgoing events

The "out" array defines the list of outgoing events (those generated by the CEP). Each outgoing event can have multiple brokers.
For each broker, the CEP will trigger /updateContext requests to the broker on each event update.

```sequence
participant EspR4FastData as A
participant Remote broker as B
A->B: update(S1.temp, 25)
A->B: update(S1.temp, 26)
```

### Statements

"statements" defines a list of [Esper EPL statements](http://www.espertech.com/esper/release-5.2.0/esper-reference/html/epl_clauses.html) that will interact with the events previously defined.
